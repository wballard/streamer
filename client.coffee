###
# Overview

This is the main application script. It:

- defines a root application, store at this.app, which in the browser is window.app
- sets up a CommonJS module repository
- tracks the dependency graph generated by require
- fulfills require() calls via promises using a [two pass technique](#two-pass)
- exposes via exports
- tracks modules by their source name
- tracks modules by their module.id
- connects socket.io to get hot code updates

# Hot Updates
Any time you change a watched module, it will be redelivered to this client via socket.io. Even more than that, the require chain is a dependency graph, so that modules will be rebound when lower level dependencies change.

# Two Pass {#two-pass}
Code loading will make *at least* two passes if there is a require statement. This is actually running the code, not trying to tweak past it with regular expressions that short out require, since require can plenty well be a function on function!

Code needs to be reloadable, which means that it will be run more than once in a given browser session. With this in mind, you will need to pay attention to a few key things at the top level of your script
- If you register events, you should do so with namespaces and turn them off at the start of your script
- If you manipulate the DOM, you should be prepared to remove your changes

Now, if you put your event registration and DOM manipulation in event handlers then this is less of a concern, just know that your script will *run* when it is hot loaded. And it will be run at least twice if you use require at all. This is because the require system will set a dependency, and likley that code will not be available. So, your script on the first run will end up with a require that doesn't quite work yet!

Once that required code is loaded, your script will be run again, it may:
- work without error
- hit another require statement, triggering another dependency pass
- errors our, in which case it is not available
###

#keep track of code as it is loading
loading = {}

#loaded code modules are kept here along with their exports
loaded = {}

#call when we start loading, and this may just ask the server for bytes
loadingCode = (socket, module_name, ask_server_for_code, force) ->
    if (loading[module_name] or loaded[module_name]) and not force
        #reload prevention
    else
        loading[module_name] = true
        if ask_server_for_code
            socket.emit('load', module_name)
        else
            console.log "loading #{module_name}"

#call when we are done loading
loadedCode = (socket, module_name, module) ->
    console.log("loaded #{module_name}", app) if app.log
    loaded[module_name] = module
    #all dependent modules need to be reloaded
    dependent_modules = dependencies[module_name] or []
    for dependent_module, _ of dependent_modules
        loadingCode socket, dependent_module, true, true

#keep track of dependencies built up via require
dependencies = {}
trackRequirement = (module_name, requires_module_name) ->
    chain = dependencies[requires_module_name] or {}
    chain[module_name] = true
    dependencies[requires_module_name] = chain

#make things visible at the top level as an app
@app = app = {}
app.log = true
app.loaded = loaded
#code promised in the future, take actions on this promise
app.promiseCode = (module_name) ->
    if not deferred[module_name]
        deferred[module_name] = new $.Deferred()
    deferred[module_name].promise()


#hooking up to socket.io to get code updates, this is where templates
#and code come from -- and this is it, the rest of the application is
#dynamically loaded
socket = io.connect('')
socket.on 'code', (data) ->
    loadingCode socket, data.module_name, false, true
    #a context that shorts out part of the application, so that app is still
    #our 'global', but we can have a temporaty exports and module buffer
    #this approach lets libraries like handlebars that install into a global
    #'this' get hooked into our app, not window.
    app.exports = {}
    app.module =
            id: data.module_name
            exports: app.exports
    app.require = (module_name) ->
        #requirements set up a dependency chain
        trackRequirement data.module_name, module_name
        #first things first, we may actually have code already loaded
        return loaded[module_name] if loaded[module_name]
        #and of course, we need to load the required module, if it isn't around
        loadingCode socket, module_name, true, false
        throw "#{module_name} not yet available"
    #call in context, 'this' is app for the injected code, so all our hot loaded
    #code is run inside the app, not in the browser or global
    try
        Function(
            """
                require = this.require;
                exports = this.exports;
                module = this.module;
                console.log(this);
                #{data.source}
            """).call(app)
        loadedCode(socket, data.module_name, app.module)
    catch e
        console.log(e, data, app) if app.log


